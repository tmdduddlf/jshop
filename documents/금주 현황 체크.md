# [script]
```너무 좋아. 보완 요청할 부분이 있어.
내용확인을 편하게 하기 위해 전체 내용을 다 표시해줘. 생략해서 바뀐부분만 보여주지말고.
바뀐부분은 인지할 수 있도록 표시해서 설명해주고.
금주 현황을 체크할 수 있는 웹 사이트를 만들려고해.
술을 마신 날과 안마신 날 표시하려해.
필요한 기능을 생각해줘.
기획안을 작성해줘.
프로그램도 만들어줘.
프론트엔드, 백엔드, DB 관련된 내용은 MYBATIS 를 활용한 MAPPER, XML, H2, ORACLE 기준으로 모두 만들어줘.
백엔드 소스 작성시 lombok 등을 활용하여 최대한 미니멀한 소스로 코딩부탁해.
화면 디자인도 미니멀하면서 세련된 디자인, 그리고 기능이 직관적으로 이해가능한 디자인으로 고려해줘.
또한 작성해준 화면외에도 기록 추가 폼, 수정/삭제 기능, 상세 조회 등의 기능을 확장한 소스까지 모두 구현부탁해.
pinia 를 기준으로한 아키텍처는 마음에 들어.
여기까지는 잘 구현해줬어.
하지만 캘린더뷰는 오픈소스 캘린더뷰를 적용해서 상세한 설명과 함께 구현해줘.
오픈소스 세팅방법까지 상세히 알려주고.
달력에서도 `기록 추가/수정/상세 조회`까지 가능하도록 구현해줘.
다 좋은데 음주관련 날짜 데이터를 다루는 부분이 좀 마음에 안드네.
`yyyyMMdd hh24:mi 형태`로 조회부터 해서 이형태로 관리되도록 백엔드, 프론트엔드에 코딩되는게 개발/유지보수도 편할 것 같아.
그리고 이 데이터 포맷은 변경하기 쉽도록 한 곳에서 형태를 지정해서 데이터 구조화 시킬 수 있도록 구현해줘.
데이터는 `등록일`과 `수정일`도 관리되어야 해. 구현해줘.
```
---
아래는 “금주 현황 체크” 웹 사이트의 전체 솔루션 예시입니다.  
이 솔루션은 사용자가 매일 음주 여부('Y' 또는 'N')와 메모를 기록하고,  
캘린더 뷰(외부 오픈소스 v‑calendar 적용)를 통해 기록 추가, 수정, 삭제, 상세 조회를 할 수 있도록 구현되어 있습니다.  
이번 버전에서는 음주 기록 날짜를 **"yyyyMMdd hh24:mi"** 형태로 관리하며,  
등록일(regDate)과 수정일(updDate)도 함께 관리하도록 변경했습니다.  
날짜 포맷 관련 처리는 **DateUtil** 클래스를 통해 한 곳에서 관리할 수 있도록 하였습니다.  
아래 각 부분은 전체 내용을 생략 없이 표시하며,  
**[Modified: ...]** 주석으로 변경/추가된 부분을 명시했습니다.

---

# 1. 기획안

- **목표:**
    - 사용자가 매일 음주 여부와 메모를 **"yyyyMMdd hh24:mi"** 형식(예: "20250501 14:30")으로 기록하고,
    - 캘린더 뷰에서 월별로 음주 기록을 직관적으로 확인하며,
    - 캘린더 내에서 기록 추가, 수정, 삭제, 상세 조회가 가능하도록 한다.

- **주요 기능:**
    1. **기록 CRUD:**
        - 날짜, 음주 여부, 메모, 등록일, 수정일을 기록
        - 기록 추가, 수정, 삭제, 상세 조회
    2. **기간별 조회 및 캘린더 뷰:**
        - 선택한 기간(예: 현재 달)의 모든 기록 조회
        - v‑calendar 오픈소스 캘린더를 통해 각 날짜별 상태를 색상으로 표시
    3. **캘린더 내 CRUD:**
        - 캘린더 셀 클릭 시 모달 창에서 해당 날짜의 기록을 추가/수정/상세 조회
    4. **날짜 포맷 통합 관리:**
        - 모든 날짜 데이터("STATUS_DATE", "REG_DATE", "UPD_DATE")를 **"yyyyMMdd hh24:mi"** 형태로 관리
        - DateUtil 클래스를 통해 포맷 변경이 용이하도록 함

- **시스템 구성:**
    - **DB:** Oracle/H2 – DRINK_STATUS 테이블 (날짜 필드는 문자열로 저장)
    - **백엔드:** Spring Boot + MyBatis
        - VO, Mapper(인터페이스 + XML), Service, Controller
        - Lombok을 사용하여 미니멀하게 구현
    - **프론트엔드:** Vue 3 + TypeScript + Pinia, v‑calendar 오픈소스 적용
        - 기록 추가 폼, 수정/삭제, 상세 조회 기능 포함

---

# 2. DB 설계

## 2-1. Oracle DDL
**[Modified: STATUS_DATE, REG_DATE, UPD_DATE를 VARCHAR2(16)로 저장하여 "yyyyMMdd hh24:mi" 형태 관리]**

```sql
-- Oracle: 시퀀스 생성
CREATE SEQUENCE DRINK_STATUS_SEQ
  START WITH 1
  INCREMENT BY 1
  NOCACHE
  NOCYCLE;

-- Oracle: DRINK_STATUS 테이블 생성
CREATE TABLE DRINK_STATUS (
  ID             NUMBER         PRIMARY KEY,
  STATUS_DATE    VARCHAR2(16)   NOT NULL,       -- yyyyMMdd hh24:mi (예: "20250501 14:30")
  DRANK          VARCHAR2(10)   DEFAULT 'N',    -- 'Y'이면 음주, 'N'이면 금주
  NOTES          VARCHAR2(200),
  REG_DATE       VARCHAR2(16),                  -- 등록일 (yyyyMMdd hh24:mi)
  UPD_DATE       VARCHAR2(16)                   -- 수정일 (yyyyMMdd hh24:mi)
);
```

## 2-2. H2 DDL
**[Modified: STATUS_DATE, REG_DATE, UPD_DATE를 VARCHAR(16)로 관리]**

```sql
-- H2: 시퀀스 생성
CREATE SEQUENCE DRINK_STATUS_SEQ START WITH 1 INCREMENT BY 1;

-- H2: DRINK_STATUS 테이블 생성
CREATE TABLE DRINK_STATUS (
  ID            BIGINT       PRIMARY KEY,
  STATUS_DATE   VARCHAR(16)  NOT NULL,      -- yyyyMMdd hh24:mi
  DRANK         VARCHAR(10)  DEFAULT 'N',
  NOTES         VARCHAR(200),
  REG_DATE      VARCHAR(16),                 -- 등록일
  UPD_DATE      VARCHAR(16)                  -- 수정일
);
```

---

# 3. 백엔드 소스 (Spring Boot + MyBatis)

## 3-1. 유틸리티 클래스 – DateUtil.java
**[New: 날짜 포맷을 관리하는 중앙 유틸리티 클래스]**

```java
// src/main/java/com/example/util/DateUtil.java
package com.example.util;

import java.text.SimpleDateFormat;
import java.util.Date;

public class DateUtil {
    // 원하는 포맷: "yyyyMMdd hh24:mi" (Java에서는 "yyyyMMdd HH:mm" 사용)
    private static final String FORMAT = "yyyyMMdd HH:mm";
    
    public static String format(Date date) {
        if (date == null) return "";
        return new SimpleDateFormat(FORMAT).format(date);
    }
}
```

## 3-2. VO – DrinkStatus.java
**[Modified: 날짜 필드를 String으로 변경; regDate와 updDate 추가]**

```java
// src/main/java/com/example/domain/DrinkStatus.java
package com.example.domain;

import lombok.Data;

@Data
public class DrinkStatus {
    private Long id;           // 시퀀스 기반 PK
    // [Modified: yyyyMMdd HH:mm 형태로 관리]
    private String statusDate; // 기록 날짜
    private String drank;      // 'Y' 또는 'N'
    private String notes;      // 메모 (옵션)
    private String regDate;    // 등록일
    private String updDate;    // 수정일
}
```

## 3-3. Mapper 인터페이스 – DrinkStatusMapper.java

```java
// src/main/java/com/example/mapper/DrinkStatusMapper.java
package com.example.mapper;

import com.example.domain.DrinkStatus;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

@Mapper
public interface DrinkStatusMapper {
    List<DrinkStatus> findByDateRange(String startDate, String endDate);
    DrinkStatus findById(Long id);
    void insert(DrinkStatus drinkStatus);
    void update(DrinkStatus drinkStatus);
    void delete(Long id);
}
```

## 3-4. XML Mapper – DrinkStatusMapper.xml

```xml
<!-- src/main/resources/mapper/DrinkStatusMapper.xml -->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
   "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.DrinkStatusMapper">
    <select id="findByDateRange" resultType="com.example.domain.DrinkStatus">
        SELECT ID,
               STATUS_DATE AS statusDate,
               DRANK,
               NOTES,
               REG_DATE AS regDate,
               UPD_DATE AS updDate
          FROM DRINK_STATUS
         WHERE STATUS_DATE BETWEEN #{startDate} AND #{endDate}
         ORDER BY STATUS_DATE
    </select>
    
    <select id="findById" parameterType="long" resultType="com.example.domain.DrinkStatus">
        SELECT ID,
               STATUS_DATE AS statusDate,
               DRANK,
               NOTES,
               REG_DATE AS regDate,
               UPD_DATE AS updDate
          FROM DRINK_STATUS
         WHERE ID = #{id}
    </select>
    
    <insert id="insert" parameterType="com.example.domain.DrinkStatus">
        INSERT INTO DRINK_STATUS (ID, STATUS_DATE, DRANK, NOTES, REG_DATE, UPD_DATE)
        VALUES (DRINK_STATUS_SEQ.NEXTVAL, #{statusDate}, #{drank}, #{notes}, #{regDate}, #{updDate})
    </insert>
    
    <update id="update" parameterType="com.example.domain.DrinkStatus">
        UPDATE DRINK_STATUS
           SET STATUS_DATE = #{statusDate},
               DRANK = #{drank},
               NOTES = #{notes},
               UPD_DATE = #{updDate}
         WHERE ID = #{id}
    </update>
    
    <delete id="delete" parameterType="long">
        DELETE FROM DRINK_STATUS WHERE ID = #{id}
    </delete>
</mapper>
```

## 3-5. Service – DrinkStatusService.java
**[Modified: 등록일/수정일을 DateUtil을 활용하여 관리하도록 구현]**

```java
// src/main/java/com/example/service/DrinkStatusService.java
package com.example.service;

import com.example.domain.DrinkStatus;
import com.example.mapper.DrinkStatusMapper;
import com.example.util.DateUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Date;
import java.util.List;

@Service
public class DrinkStatusService {

    @Autowired
    private DrinkStatusMapper mapper;
    
    public List<DrinkStatus> getStatuses(String startDate, String endDate) {
        return mapper.findByDateRange(startDate, endDate);
    }
    
    public DrinkStatus getStatus(Long id) {
        return mapper.findById(id);
    }
    
    public void addStatus(DrinkStatus status) {
        String now = DateUtil.format(new Date());
        status.setRegDate(now);
        status.setUpdDate(now);
        mapper.insert(status);
    }
    
    public void updateStatus(DrinkStatus status) {
        status.setUpdDate(DateUtil.format(new Date()));
        mapper.update(status);
    }
    
    public void deleteStatus(Long id) {
        mapper.delete(id);
    }
}
```

## 3-6. Controller – DrinkStatusController.java

```java
// src/main/java/com/example/controller/DrinkStatusController.java
package com.example.controller;

import com.example.domain.DrinkStatus;
import com.example.service.DrinkStatusService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/drink-status")
public class DrinkStatusController {

    @Autowired
    private DrinkStatusService service;
    
    // 기간별 기록 조회: GET /api/drink-status?startDate=yyyyMMdd hh:mm&endDate=yyyyMMdd hh:mm
    @GetMapping
    public List<DrinkStatus> getStatuses(@RequestParam("startDate") String startDate,
                                          @RequestParam("endDate") String endDate) {
        return service.getStatuses(startDate, endDate);
    }
    
    // 단건 상세 조회: GET /api/drink-status/{id}
    @GetMapping("/{id}")
    public DrinkStatus getStatus(@PathVariable Long id) {
        return service.getStatus(id);
    }
    
    // 기록 추가
    @PostMapping
    public void createStatus(@RequestBody DrinkStatus status) {
        service.addStatus(status);
    }
    
    // 기록 수정
    @PutMapping("/{id}")
    public void updateStatus(@PathVariable Long id, @RequestBody DrinkStatus status) {
        status.setId(id);
        service.updateStatus(status);
    }
    
    // 기록 삭제
    @DeleteMapping("/{id}")
    public void deleteStatus(@PathVariable Long id) {
        service.deleteStatus(id);
    }
}
```

---

# 4. 프론트엔드 소스 (Vue 3 + TypeScript + Pinia)

## 4-1. Pinia Store – drinkStatusStore.ts
**[Modified: statusDate를 yyyyMMdd hh:mm 형식의 문자열로 관리]**

```ts
// src/stores/drinkStatusStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import axios from 'axios';

export interface DrinkStatus {
  id: number;
  // [Modified: yyyyMMdd hh:mm 형식의 문자열]
  statusDate: string; // e.g. "20250501 14:30"
  drank: string;      // 'Y' (음주) or 'N' (금주)
  notes: string;
  regDate: string;
  updDate: string;
}

export const useDrinkStatusStore = defineStore('drinkStatus', () => {
  const statuses = ref<DrinkStatus[]>([]);
  const loading = ref(false);
  const error = ref<string | null>(null);

  async function fetchStatuses(startDate: string, endDate: string) {
    loading.value = true;
    error.value = null;
    try {
      const res = await axios.get<DrinkStatus[]>('/api/drink-status', {
        params: { startDate, endDate }
      });
      statuses.value = res.data;
    } catch (e: any) {
      error.value = e.message || 'Error fetching statuses';
    } finally {
      loading.value = false;
    }
  }

  async function createStatus(status: Partial<DrinkStatus>) {
    await axios.post('/api/drink-status', status);
  }

  async function updateStatus(id: number, status: Partial<DrinkStatus>) {
    await axios.put(`/api/drink-status/${id}`, status);
  }

  async function deleteStatus(id: number) {
    await axios.delete(`/api/drink-status/${id}`);
  }

  async function fetchStatusById(id: number): Promise<DrinkStatus | null> {
    try {
      const res = await axios.get<DrinkStatus>(`/api/drink-status/${id}`);
      return res.data;
    } catch (e: any) {
      return null;
    }
  }

  return { statuses, loading, error, fetchStatuses, createStatus, updateStatus, deleteStatus, fetchStatusById };
});
```

## 4-2. 오픈소스 캘린더(v‑calendar) 전역 등록
**[Modified: v‑calendar 설치 및 전역 등록 추가]**

```ts
// src/main.ts
import { createApp } from 'vue';
import App from './App.vue';
import { createPinia } from 'pinia';
import VCalendar from 'v-calendar';

const app = createApp(App);
app.use(createPinia());
app.use(VCalendar, {
  componentPrefix: 'vc'
});
app.mount('#app');
```

## 4-3. ExternalCalendar.vue – v‑calendar 적용 캘린더 컴포넌트 및 캘린더 내 CRUD
**[Modified: 날짜 포맷 yyyyMMdd hh:mm 사용 및 모달 추가]**

```vue
<template>
  <div class="external-calendar">
    <vc-calendar
      :attributes="attributes"
      is-expanded
      :min-date="minDate"
      :max-date="maxDate"
      @dayclick="handleDayClick"
    />
    <!-- Modal for record CRUD -->
    <div v-if="showModal" class="modal">
      <div class="modal-content">
        <h3>{{ editing ? 'Edit Record' : 'Add Record' }}</h3>
        <label>
          Date:
          <input type="text" v-model="form.statusDate" disabled />
        </label>
        <label>
          Status:
          <select v-model="form.drank">
            <option value="Y">술 마신 날</option>
            <option value="N">금주</option>
          </select>
        </label>
        <label>
          Notes:
          <input type="text" v-model="form.notes" />
        </label>
        <div class="actions">
          <button @click="saveRecord">{{ editing ? 'Update' : 'Add' }}</button>
          <button @click="closeModal">Close</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { useDrinkStatusStore } from '@/stores/drinkStatusStore';

const store = useDrinkStatusStore();

// 날짜 기본 설정: 이번 달 기준
const today = new Date();
const minDate = ref(new Date(today.getFullYear(), today.getMonth(), 1));
const maxDate = ref(new Date(today.getFullYear(), today.getMonth() + 1, 0));

// [Modified: attributes 업데이트 – 날짜는 yyyyMMdd hh:mm 형식]
const attributes = ref([
  {
    key: 'drank',
    highlight: { backgroundColor: '#ffcccc' },
    dates: [] as string[]
  },
  {
    key: 'notDrank',
    highlight: { backgroundColor: '#ccffcc' },
    dates: [] as string[]
  }
]);

// Modal 및 폼 상태
const showModal = ref(false);
const editing = ref(false);
const form = ref({
  id: 0,
  statusDate: '',  // yyyyMMdd hh:mm
  drank: 'N',
  notes: ''
});

// 중앙에서 날짜 포맷을 관리하는 헬퍼 함수
function formatDate(date: Date): string {
  const yyyy = date.getFullYear().toString();
  const mm = (date.getMonth() + 1).toString().padStart(2, '0');
  const dd = date.getDate().toString().padStart(2, '0');
  const hh = date.getHours().toString().padStart(2, '0');
  const mi = date.getMinutes().toString().padStart(2, '0');
  return `${yyyy}${mm}${dd} ${hh}:${mi}`;
}

async function loadCalendar() {
  const start = formatDate(minDate.value).split(' ')[0].replace(' ', ''); // yyyyMMdd (for query, you may ignore time)
  const end = formatDate(maxDate.value).split(' ')[0].replace(' ', '');
  await store.fetchStatuses(start, end);
  const drankDates: string[] = [];
  const notDrankDates: string[] = [];
  store.statuses.forEach(record => {
    if (record.drank === 'Y') {
      drankDates.push(record.statusDate);
    } else {
      notDrankDates.push(record.statusDate);
    }
  });
  attributes.value = [
    { key: 'drank', highlight: { backgroundColor: '#ffcccc' }, dates: drankDates },
    { key: 'notDrank', highlight: { backgroundColor: '#ccffcc' }, dates: notDrankDates }
  ];
}

onMounted(() => {
  loadCalendar();
});

// 캘린더 셀 클릭: 해당 날짜에 기록이 있으면 편집, 없으면 새 기록 추가
function handleDayClick(day: any) {
  const dateStr = formatDate(day.date);
  form.value.statusDate = dateStr;
  const record = store.statuses.find(s => s.statusDate === dateStr);
  if (record) {
    editing.value = true;
    form.value = { ...record };
  } else {
    editing.value = false;
    form.value = { statusDate: dateStr, drank: 'N', notes: '' };
  }
  showModal.value = true;
}

async function saveRecord() {
  if (editing.value) {
    await store.updateStatus(form.value.id, form.value);
  } else {
    await store.createStatus(form.value);
  }
  await loadCalendar();
  closeModal();
}

function closeModal() {
  showModal.value = false;
}
</script>

<style scoped>
.external-calendar {
  max-width: 600px;
  margin: 1rem auto;
  padding: 1rem;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 8px;
}
.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
}
.modal-content {
  background: #fff;
  padding: 1rem;
  border-radius: 6px;
  max-width: 400px;
  width: 100%;
}
.modal-content label {
  display: block;
  margin-bottom: 0.5rem;
}
.actions {
  margin-top: 1rem;
  text-align: right;
}
.actions button {
  margin-left: 0.5rem;
}
</style>
```

### 4-4. 기록 추가/수정/상세 조회 폼 – DrinkStatusForm.vue
*(참고: ExternalCalendar.vue 내에서 모달로 처리하므로 별도의 폼 컴포넌트가 선택 사항입니다. 아래는 기존 폼 예시입니다.)*

```vue
<template>
  <div class="status-form">
    <h3>{{ editing ? 'Edit Record' : 'Add Record' }}</h3>
    <label>
      Date:
      <input type="date" v-model="form.statusDate" disabled />
    </label>
    <label>
      Status:
      <select v-model="form.drank">
        <option value="Y">술 마신 날</option>
        <option value="N">금주</option>
      </select>
    </label>
    <label>
      Notes:
      <input type="text" v-model="form.notes" />
    </label>
    <div class="actions">
      <button @click="saveRecord">{{ editing ? 'Update' : 'Add' }}</button>
      <button v-if="editing" @click="cancelEdit">Cancel</button>
    </div>
    <div v-if="detail">
      <h4>Record Detail</h4>
      <p>Date: {{ detail.statusDate }}</p>
      <p>Status: {{ detail.drank === 'Y' ? '술 마신 날' : '금주' }}</p>
      <p>Notes: {{ detail.notes }}</p>
      <button @click="closeDetail">Close</button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useDrinkStatusStore, DrinkStatus } from '@/stores/drinkStatusStore';

const store = useDrinkStatusStore();
const editing = ref(false);
const editingId = ref<number | null>(null);
const form = ref<Partial<DrinkStatus>>({
  statusDate: '',
  drank: 'N',
  notes: ''
});
const detail = ref<DrinkStatus | null>(null);

async function saveRecord() {
  if (editing.value && editingId.value !== null) {
    await store.updateStatus(editingId.value, form.value);
  } else {
    await store.createStatus(form.value);
  }
  resetForm();
}

function editRecord(record: DrinkStatus) {
  editing.value = true;
  editingId.value = record.id;
  form.value = { ...record };
}

function deleteRecord(id: number) {
  store.deleteStatus(id).then(() => {
    // Optionally refresh list in parent
  });
}

async function viewDetail(id: number) {
  const rec = await store.fetchStatusById(id);
  detail.value = rec;
}

function closeDetail() {
  detail.value = null;
}

function cancelEdit() {
  resetForm();
}

function resetForm() {
  editing.value = false;
  editingId.value = null;
  form.value = { statusDate: '', drank: 'N', notes: '' };
}
</script>

<style scoped>
.status-form {
  border: 1px solid #eee;
  padding: 1rem;
  border-radius: 4px;
  margin-top: 1rem;
}
.status-form label {
  display: block;
  margin-bottom: 0.5rem;
}
.actions {
  margin-top: 1rem;
}
.actions button {
  margin-right: 0.5rem;
}
h4 {
  margin-top: 1rem;
  color: #333;
}
</style>
```

### 4-5. 금주 현황 페이지 – DrinkStatusPage.vue

```vue
<template>
  <div class="drink-status-page">
    <h2>금주 현황 체크</h2>
    <!-- v‑calendar 기반 캘린더 뷰 (ExternalCalendar.vue) -->
    <ExternalCalendar />
    <!-- (추가로 별도 기록 목록, 폼 등 필요 시 포함 가능) -->
    <!-- 여기서는 ExternalCalendar.vue 내에서 기록 CRUD를 지원 -->
  </div>
</template>

<script setup lang="ts">
import ExternalCalendar from '@/components/ExternalCalendar.vue';
</script>

<style scoped>
.drink-status-page {
  max-width: 800px;
  margin: 0 auto;
  padding: 1rem;
}
</style>
```

---

# 5. 변경 및 추가된 부분 요약

1. **DB/백엔드 변경:**
    - **[Modified: STATUS_DATE, REG_DATE, UPD_DATE를 VARCHAR(16)로 저장하여 "yyyyMMdd hh:mm" 형식 관리]**
    - VO의 **statusDate** 타입을 **String**으로 변경하고, regDate 및 updDate 필드 추가
    - Mapper, XML, Service에서 String으로 날짜 관리 및 DateUtil을 사용해 포맷 지정

2. **프론트엔드 변경:**
    - **[Modified: 날짜 형식을 "yyyyMMdd hh:mm"로 통일 – Pinia 스토어 및 v‑calendar에서 사용]**
    - main.ts에 v‑calendar 전역 등록 및 사용 방법 상세히 추가
    - **ExternalCalendar.vue**를 통해 캘린더 셀 클릭 시 모달 창이 열려 기록 추가/수정/상세 조회가 가능하도록 구현
    - 날짜 포맷 변환 함수 (formatDate)를 중앙에서 관리하여 유지보수 용이

3. **캘린더뷰 선택:**
    - 오픈소스 캘린더 **v‑calendar**를 적용함으로써 풍부한 기능과 빠른 개발을 도모
    - 기존 커스텀 캘린더 코드는 참고용으로 제공 (CustomCalendar.vue)

4. **전체 시스템:**
    - **기획안:** 금주 현황 체크 및 캘린더 내 CRUD 기능
    - **DB:** Oracle/H2에서 DRINK_STATUS 테이블 사용
    - **백엔드:** Spring Boot + MyBatis 기반 CRUD API (Lombok, DateUtil 사용)
    - **프론트엔드:** Vue 3 + TypeScript + Pinia, v‑calendar를 활용한 캘린더 뷰 및 모달 기반 CRUD

---

# 6. 결론

이 전체 솔루션은
- 음주 기록 날짜를 **"yyyyMMdd hh:mm"** 형태로 통일 관리하고,
- 등록일과 수정일도 함께 관리하도록 설계되었으며,
- 백엔드와 프론트엔드 모두 미니멀하고 확장 가능한 코드를 제공하여 유지보수를 용이하게 합니다.
- 캘린더뷰는 v‑calendar 오픈소스를 사용하여 풍부한 기능과 세련된 디자인을 제공하며,
- 캘린더 내에서 기록 추가/수정/상세 조회가 가능하도록 모달 창을 통한 인터랙션을 구현하였습니다.

위 전체 소스와 기획안을 참고하여 금주 현황 체크 웹 사이트 개발에 바로 착수할 수 있습니다.